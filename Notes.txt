L1 2020-09-01
------------------------

- Lab 2 & 3 are presented to a supervisor

L2 2020-09-04
------------------------
let & where synonyms

fun x = 
    let x' = abs x in
        x' + 5
fun x = x' + 5 where
    x' = abs x

L3B IO
------------------------

Pure functions make it hard to have randomness and reading from files, as all functions should return the same output for the same input

Type IO t to get around this: this package can have side-effects

IO String: Side effects, and return a string, IO Integer: Side effects, and return an integer

writeFile :: FilePath -> String -> IO ()
	IO (): function returns an instruction to the operating system
		(): Unit type (no return value, empty tuple, only a side effect)

Interaction with the outside world has to go through IO

Extract returned value from IO:
	s <- readFile "Hello.txt"
	NOT s = readfile (as this would be of type IO String, not string)
	<- binds the result of an instruction (or monad??)

do-notation:
	Combining instructions
	Has to __return__ an instruction with a result
		return :: a -> IO a

read :: Read a => String -> a

L4A - Test Data Generators
------------------------

QuickCheck needs to know how to generate random values (knows for several known types)

For some cases, we need to tell quickCheck how to generate random values
	- Your own data type
	- Custom restrictions on values 

functions can take instructions as arguments

A generic instruction is of type Monad
	It can have any type of return type 
	All can be built using Do-notation

Gen: A type of monad
	Instead of instructions to the OS, it gives instructions to QuickCheck!
	IO t: ghc runs the instruction, creates value of type t
	Gen t: QuickCheck library runs the instruction, creates random value of type t

	arbitrary :: Gen t 
		sample (arbitrary :: Gen t) will print out a sample of random values of type t

	If you have a Gen t in the type signature, QuickCheck will infer that arbitrary should be of type Gen t

	QuickCheck generates random values that go from small to big, not completely random (since it is made for testing)

listOf :: Gen a -> Gen [a]
	If you have a generator for random numbers, listOf will give you a generator for random lists of numbers

vectorOf :: Int -> Gen a -> Gen [a]
	Same as listOf, but with a fixed length (int)

choose :: Random a => (a, a) -> Gen a
	Pair (x, y) is a range between with values of type a must lie

elements :: [a] -> Gen a
	Takes a list of elements and generates random values from that list

oneof :: [Gen a] -> Gen a
	Chooses one of a list of generators (useful if you want to combine generators into a single instance of abritrary)

collect 
	Gives you information about the generated values (if you want to see the percentages of what values are being generated in the testing)

frequency :: [(Int, Gen a)] -> Gen a
	If you want to adjust the distribution of values. The Int is the relative frequency of that generator being used. [(5, r1), (3, r2)]: 5:3 ratio of choosing r1 over r2

Class Arbitrary
	QuickCheck can generate anything of the class Arbitrary
		Need to make your data type an instace of Arbitrary
	basically: 
		rType :: Gen Type
		rType = elements [...]
	Instance Arbitrary Type where
		arbitrary = rType

		abritrary can be defined with a do-block that combines instructions, ending in a return

